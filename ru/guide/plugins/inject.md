# Изменение функций {#inject}

В этом руководстве рассматривается концепция изменение функций, также иногда называемая [обезьяний патч](https://ru.wikipedia.org/wiki/Monkey_patch). 

Если вы уже знакомы с этой концепцией можете перейти сразу к [примерам](#examples).

### Что это такое? {#what-is-it}

Исправление функций — усовершенствованная технология для плагинов, которая позволяет вам изменять существующие функции. 
Существует два разных «вида» патчей. Есть те, где вы запускаете свой собственный код перед исходной функцией обычно имеет целью изменить аргументы перед их передачей исходной функции. 
И есть те, которые предназначены для запуска после исходной функции с целью изменения возвращаемого значения перед его передачей куда-либо еще.

### Как я могу исправить функцию ? {#how-to-fix-function}

К сожалению, вы не можете исправить функцию напрямую, вам придется изменить ссылку на функцию, которую использует другой код. 
Это означает, что если ваша целевая функция — это просто локально или глобально доступная функция, подобная этой

```js
function target() {}
```
Вы не сможете на это повлиять. Однако, если ваша цель является частью модуля,
вы можете перезаписать эту ссылку своей собственной функцией, в результате чего все вместо этого будут вызывать вашу функцию.

```js
const module = {
  target: function() {
      return 'red'
    }
};

function getColor() {
  return module.target();
}
getColor(); // 'red'

function myPatch() { // [!code highlight]
   return 'green'; // [!code highlight]
} // [!code highlight]

module.target = myPatch; // [!code highlight]

getColor(); // 'green' - исправлено
```

Если вы посмотрите на выделенный раздел, мы создаем новую функцию `myPatch()` оно возвращает _green_ и присваиваем его `module.target()` эффективно перезаписывая целевую функцию. 
Это значит, когда `getColor()` вызывается снова, ваша функция запускается успешно, поскольку она ссылается на `module` объект. 
Наш патч полностью заменяет цель. Все патчи начинаются таким образом, но их можно расширить и превратить в `pre` или `post` патч, 
сохранив ссылку и вызвав исходную функцию. Но если несколько плагинов будем патчить одну и ту же функцию это может быстро усложнится.

### Injector {#injector}

К счастью, Yskra уже имеет модуль для управления несколькими исправлениями для каждой функции и позволяет нацеливаться на разные типы исправлений. 
Это означает, что если вы хотите сделать `pre` или `post` патч, вам больше не придется вручную заменять функцию, сохранять ссылки и вызывать оригинал. 
Все это делается за вас. Давайте посмотрим, как можно реализовать приведенный выше пример с помощью этого модуля. 

`injector` является частью контекста плагина.

```js
const module = {
  target: function() {
    return 'red'
  }
};

function getColor() {
  return module.target();
}
getColor(); // 'red'

ctx.injector.post(module, 'target', () => { // [!code highlight]
  return 'green'; // [!code highlight]
}, 'debug-id'); // [!code highlight]

getColor(); // 'green' - исправлено
```

Этот код имеет тот же эффект, что и раньше, вызывая `getColor()` вместо этого получает **green**. 
Но давайте внимательнее посмотрим на выделенную строку. 
- У нас есть вызов `ctx.injector.post()` что указывает на то, что мы хотим создать `post` патч. 
- Затем мы даем ему целевой объект `module`
- Имя нашей цели внутри этого объекта
- Нашу функцию для переопределения ответа
- Так же мы передаем ему идентификатор `debug-id`, который будет отображаться в логах, 
в противном случае Injector сгенерирует его самостоятельно, идентификатор так же можно использовать для `ctx.injector.uninject()` чтобы вручную удалить патч.

Injector позаботится обо всем остальном и даже позволит другим плагинам устанавливать патчи поверх вашего.

## Примеры {#examples}

Дано:
```js :line-numbers
function someGlobal() {
}

const module = {
  value: "foobar",
  method(val = 0) {
    return 1 + val;
  },
  otherMethod(someArg) {
    console.log(`My value ${someArg}`);
  }
};
```
В этой настройке `someGlobal` — это функция, которую нельзя исправить, поскольку нет ссылки на замену. 
Однако `module.method()` и `module.otherMethod()` оба могут быть исправлены. 


### inject.pre {#inject-pre}

```js
ctx.inject.pre(module, 'otherMethod', (args) => {
  console.log(args);
  return args;
});

module.otherMethod("something");

// > ["something"]
// > My value something
```
В этом примере мы не изменяли аргументы, а просто хотели вывести в консоль, чтобы посмотреть, какие значения мы можем получить.
Это хороший метод, помогающий выборочно изменять аргументы. Предположим, мы не против этого `something` в консоли, но нам не нравится, когда там `token`. Как это может выглядеть ? 

```js
ctx.inject.pre(module, 'otherMethod', (args) => {
  if (args[0] === "token") { // [!code highlight]
    args[0] = "no"; // [!code highlight]
  } // [!code highlight]
  return args;
});

module.otherMethod("something"); // > My value something
module.otherMethod("token");     // > My value no
```
Подсвеченный код проверяет, когда кто-то подсовывает `token` как значение для `module.otherMethod()` тогда заменяет его на `no`.


### inject.post {#inject-post}

Этот тип патчей, пожалуй, наиболее часто используется в плагинах.

```js
ctx.inject.post(module, 'method', (returned, args) => {
  return returned * 2;
});

module.method(5); // > 12
module.method();  // > 2
```
Вы заметите это оригинальная функция превратилась в `returned`. 
Здесь мы просто умножаем ответ на 2 каждый раз и возвращаем значение вызывающему. 
Это означает, что для любого числа, применяется исходная функция, затем наш патч берет и умножает на `2`, и вызывающий наконец получает свое значение.
Injector будет использовать что угодно в качестве **return** значения. 
Однако если вы ничего не возвращаете, используется исходное возвращаемое значение. Это может иметь глубокие последствия. Рассмотрим этот случай ниже: 

```js
ctx.inject.post(module, 'method', (returned, args) => {
  if (args[0] === 5) 
    return null;
});
```
На этот раз в нашем патче мы возвращаем значение только в случае `5`, во всех остальных случаях используется значение по умолчанию `returned` исходной функции, поскольку мы ничего не вернули. 
Возможно, вы также заметили, что наш возврат больше не является числом. Так что же происходит с нашим случаем выше ? 

```js
ctx.inject.post(module, 'method', (returned, args) => {
  if (args[0] === 5) 
    return null;
});

const myNumber = 5 / module.method(5); // NaN
```

Эта переменная `myNumber` стала `NaN` - not a number. Что иронично, учитывая имя переменной. 
Но это хороший пример того, насколько осторожными нужно быть, когда дело доходит до изменения результатов функций. 
